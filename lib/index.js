var c=Object.create;var o=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var b=(r,e)=>{for(var t in e)o(r,t,{get:e[t],enumerable:!0})},s=(r,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of p(e))!v.call(r,n)&&n!==t&&o(r,n,{get:()=>e[n],enumerable:!(i=h(e,n))||i.enumerable});return r};var E=(r,e,t)=>(t=r!=null?c(u(r)):{},s(e||!r||!r.__esModule?o(t,"default",{value:r,enumerable:!0}):t,r)),w=r=>s(o({},"__esModule",{value:!0}),r);var S={};b(S,{NatsConnection:()=>m,Subscription:()=>l,connect:()=>g});module.exports=w(S);var d=E(require("node:events"));const a="closed";class l{constructor(e,t,i){this.eventEmitter=e;this.subject=t;this.opts=i;this.eventEmitter.on(t,n=>{this.yields.add(n)}),this.eventEmitter.on(a,()=>{this._closed()})}draining=!1;done=!1;sid=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER);yields=new Set;closedNotification=new Promise(e=>{const t=setInterval(()=>{this.done&&e(clearInterval(t))},1)});closed=this.closedNotification;unsubscribe(e){this._closed()}drain(){return this.draining=!0,Promise.resolve(this._closed())}isDraining(){return this.draining&&!this.isClosed()}isClosed(){return this.done&&this.yields.size===0}callback(e,t){this.opts?.callback&&this.opts.callback(e,t)}getSubject(){return this.subject}getReceived(){throw new Error("Method not implemented.")}getProcessed(){throw new Error("Method not implemented.")}getPending(){throw new Error("Method not implemented.")}getID(){return this.sid}getMax(){return this.opts?.max}[Symbol.asyncIterator](){return this.iterate()}async*iterate(){for(;;){await new Promise(t=>{const i=setInterval(()=>{(this.done||this.yields.size>0)&&t(clearInterval(i))},1)});const e=this.yields;for(const t of e)yield{subject:this.subject,sid:this.sid,data:t};if(this.yields.clear(),this.done)break}}_closed(e){if(!this.done){try{this.eventEmitter.removeAllListeners(this.subject)}catch(t){console.log(t)}this.done=!0}}}class m{connected=!0;eventEmitter=new d.default;closedNotification=new Promise(e=>{const t=setInterval(()=>{this.connected||e(clearInterval(t))},1)});info;closed(){return this.closedNotification}close(){return this.connected&&(this.eventEmitter.emit(a),this.eventEmitter.removeAllListeners(),this.connected=!1),Promise.resolve()}publish(e,t,i){this.eventEmitter.emit(e,t)}subscribe(e,t){return new l(this.eventEmitter,e,t)}request(e,t,i){throw new Error("Method not implemented.")}flush(){throw new Error("Method not implemented.")}drain(){return this.close()}isClosed(){return!this.connected}isDraining(){throw new Error("Method not implemented.")}getServer(){throw new Error("Method not implemented.")}status(){throw new Error("Method not implemented.")}stats(){throw new Error("Method not implemented.")}jetstreamManager(e){throw new Error("Method not implemented.")}jetstream(e){throw new Error("Method not implemented.")}rtt(){throw new Error("Method not implemented.")}}function g(r){return new Promise(e=>{e(new m)})}0&&(module.exports={NatsConnection,Subscription,connect});
